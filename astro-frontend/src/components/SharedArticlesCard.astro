---
/**
 * Shared Articles Card
 *
 * Displays articles where both entities are mentioned together.
 * Used on the co-mentions comparison page.
 */

const apiUrl = import.meta.env.PUBLIC_API_URL || 'http://localhost:8000/api/v1';
---

<div id="shared-articles-card" class="shared-articles-card card" data-api-url={apiUrl}>
  <div class="card-header">
    <h3 class="card-title">Shared Articles</h3>
    <p class="card-subtitle">Articles mentioning both entities</p>
  </div>

  <div class="card-body">
    <div id="shared-loading" class="loading-skeleton">
      <div class="skeleton-item"></div>
      <div class="skeleton-item"></div>
      <div class="skeleton-item"></div>
    </div>
    <div id="shared-content" class="hidden">
      <div id="shared-list" class="content-list"></div>
    </div>
    <div id="shared-empty" class="empty-state hidden">
      No shared articles found
    </div>
  </div>
</div>

<style>
  .shared-articles-card {
    width: 100%;
    max-width: 600px;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 0.375rem;
  }

  .card-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border);
  }

  :global(.dark) .card-header {
    border-bottom-color: var(--border-dark);
  }

  .card-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text);
    margin: 0;
  }

  :global(.dark) .card-title {
    color: var(--text-dark);
  }

  .card-subtitle {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin: 0.25rem 0 0 0;
  }

  :global(.dark) .card-subtitle {
    color: var(--text-secondary-dark);
  }

  .card-body {
    padding: 1.5rem;
  }

  .loading-skeleton {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .skeleton-item {
    height: 80px;
    border-radius: 4px;
    background-color: var(--border);
    animation: pulse 2s ease-in-out infinite;
  }

  :global(.dark) .skeleton-item {
    background-color: var(--border-dark);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .content-list {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .content-item {
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border);
  }

  :global(.dark) .content-item {
    border-bottom-color: var(--border-dark);
  }

  .content-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }

  .content-title {
    font-weight: 600;
    color: var(--text);
    margin: 0 0 0.5rem 0;
    line-height: 1.4;
    font-size: 0.95rem;
  }

  :global(.dark) .content-title {
    color: var(--text-dark);
  }

  .content-title a {
    color: inherit;
    text-decoration: underline;
    text-decoration-color: var(--text-tertiary);
    text-underline-offset: 2px;
  }

  :global(.dark) .content-title a {
    text-decoration-color: var(--text-tertiary-dark);
  }

  .content-meta {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-top: 0.5rem;
  }

  :global(.dark) .content-meta {
    color: var(--text-secondary-dark);
  }

  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
  }

  :global(.dark) .empty-state {
    color: var(--text-secondary-dark);
  }

  .hidden {
    display: none;
  }
</style>

<script>
  import { escapeHtml, parseCoMentionsParams } from '../lib/utils/dom';
  import { formatDate } from '../lib/utils/date';
  import type { Article } from '../lib/utils/co-mentions';
  import { swrFetch } from '../lib/utils/api-fetcher';

  class SharedArticlesCard {
    private card: HTMLElement | null = null;
    private apiUrl = '';
    private params!: ReturnType<typeof parseCoMentionsParams>;

    private loadingEl: HTMLElement | null = null;
    private contentEl: HTMLElement | null = null;
    private listEl: HTMLElement | null = null;
    private emptyEl: HTMLElement | null = null;

    constructor() {
      const card = document.getElementById('shared-articles-card');
      if (!card) return;

      this.card = card;
      this.apiUrl = card.dataset.apiUrl || 'http://localhost:8000/api/v1';
      this.params = parseCoMentionsParams();

      this.loadingEl = document.getElementById('shared-loading');
      this.contentEl = document.getElementById('shared-content');
      this.listEl = document.getElementById('shared-list');
      this.emptyEl = document.getElementById('shared-empty');

      this.init();
    }

    private init() {
      if (!this.params.sport || !this.params.type || !this.params.id) {
        this.showEmpty();
        return;
      }

      this.fetchSharedArticles();
    }

    private async fetchSharedArticles() {
      // First get both entity names in parallel using SWR
      const [primaryName, secondaryName] = await Promise.all([
        this.getEntityName(this.params.type!, this.params.id!),
        this.params.coType && this.params.coId
          ? this.getEntityName(this.params.coType, this.params.coId)
          : Promise.resolve(null),
      ]);

      if (!primaryName || !secondaryName) {
        this.showEmpty();
        return;
      }

      // Fetch news for primary entity with sport context
      try {
        const newsParams = new URLSearchParams();
        if (this.params.sport) newsParams.set('sport', this.params.sport.toUpperCase());
        newsParams.set('limit', '20'); // New API uses limit instead of hours

        const newsUrl = `${this.apiUrl}/news/${encodeURIComponent(primaryName)}?${newsParams.toString()}`;

        // Use SWR fetch for news
        const { data } = await swrFetch<{ articles?: Array<{ title?: string; url?: string; published_at?: string; source?: string }> }>(newsUrl, {
          staleTime: 30 * 1000,      // Consider stale after 30 seconds
          cacheTime: 5 * 60 * 1000,  // Keep in cache for 5 minutes
        });

        // Transform new API response to Article format (url → link, published_at → pub_date)
        const articles: Article[] = (data.articles || []).map(a => ({
          title: a.title || '',
          link: a.url || '',
          pub_date: a.published_at,
          source: a.source,
        }));

        // Build search terms for the secondary entity
        // Include full name and last name (for players)
        const searchTerms = this.getSearchTerms(secondaryName);

        // Filter articles that mention any of the search terms
        const sharedArticles = articles.filter(article => {
          const title = (article.title || '').toLowerCase();
          return searchTerms.some(term => title.includes(term));
        });

        if (sharedArticles.length === 0) {
          this.showEmpty();
          return;
        }

        this.renderArticles(sharedArticles);
      } catch {
        this.showEmpty();
      }
    }

    private getSearchTerms(name: string): string[] {
      const terms: string[] = [];
      const lowerName = name.toLowerCase();

      // Add full name
      terms.push(lowerName);

      // Extract and add last name (for players with multi-word names)
      const parts = lowerName.split(/\s+/);
      if (parts.length > 1) {
        let lastName = parts[parts.length - 1];

        // Handle suffixes
        const suffixes = ['jr', 'jr.', 'sr', 'sr.', 'ii', 'iii', 'iv', 'v'];
        if (suffixes.includes(lastName.replace('.', '')) && parts.length >= 3) {
          lastName = parts[parts.length - 2];
        }

        // Only add last name if it's at least 4 characters
        if (lastName.length >= 4) {
          terms.push(lastName);
        }
      }

      return terms;
    }

    private async getEntityName(type: string, id: string): Promise<string | null> {
      try {
        // Use new widget/info endpoint
        const url = `${this.apiUrl}/widget/info/${type}/${id}?sport=${this.params.sport!.toUpperCase()}`;

        // Use SWR fetch for widget data
        const { data } = await swrFetch<Record<string, unknown>>(url, {
          staleTime: 60 * 1000,
          cacheTime: 30 * 60 * 1000,
        });

        // New API returns flat data
        if (type === 'team') {
          return (data.name as string) || null;
        } else {
          return `${data.firstname || ''} ${data.lastname || ''}`.trim() || (data.name as string) || null;
        }
      } catch {
        return null;
      }
    }

    private renderArticles(articles: Article[]) {
      const html = articles.map(article => this.renderArticle(article)).join('');
      if (this.listEl) this.listEl.innerHTML = html;
      this.showContent();
    }

    private renderArticle(article: Article): string {
      const title = escapeHtml(article.title || 'Untitled');
      const link = article.link || '#';
      const source = escapeHtml(article.source || '');
      const date = formatDate(article.pub_date);

      return `<div class="content-item">
        <h3 class="content-title">
          <a href="${link}" target="_blank" rel="noopener">${title}</a>
        </h3>
        <div class="content-meta">${source}${source && date ? ' · ' : ''}${date}</div>
      </div>`;
    }

    private showContent() {
      this.loadingEl?.classList.add('hidden');
      this.contentEl?.classList.remove('hidden');
      this.emptyEl?.classList.add('hidden');
    }

    private showEmpty() {
      this.loadingEl?.classList.add('hidden');
      this.contentEl?.classList.add('hidden');
      this.emptyEl?.classList.remove('hidden');
    }
  }

  new SharedArticlesCard();
</script>
