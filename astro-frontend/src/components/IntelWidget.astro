---
/**
 * Intel Widget
 *
 * Displays intelligence content (news, tweets, reddit) for an entity.
 * Fetches from multiple endpoints:
 * - GET /api/v1/news/{entity_name}?sport={sport}
 * - GET /api/v1/intel/twitter?query={name}&sport={sport}
 * - GET /api/v1/intel/reddit?query={name}&sport={sport}
 * - GET /api/v1/intel/status (to check which services are available)
 */

const apiUrl = import.meta.env.PUBLIC_API_URL || 'http://localhost:8000/api/v1';
---

<div id="intel-widget" class="intel-widget card" data-api-url={apiUrl}>
  <!-- Tab Navigation -->
  <div class="tabs-nav">
    <button class="tab-btn active" data-tab="news">News</button>
    <button class="tab-btn" data-tab="twitter">Twitter</button>
    <button class="tab-btn" data-tab="reddit">Reddit</button>
  </div>

  <!-- Tab Content -->
  <div class="tabs-content">
    <!-- News Tab -->
    <div id="news-tab" class="tab-content active">
      <div id="news-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="news-content" class="hidden">
        <div id="news-list" class="content-list"></div>
      </div>
      <div id="news-empty" class="empty-state hidden">
        No news articles found
      </div>
    </div>

    <!-- Twitter Tab -->
    <div id="twitter-tab" class="tab-content">
      <div id="twitter-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="twitter-content" class="hidden">
        <div id="twitter-list" class="content-list"></div>
      </div>
      <div id="twitter-empty" class="empty-state hidden">
        No tweets found
      </div>
      <div id="twitter-unavailable" class="empty-state hidden">
        Twitter integration not configured
      </div>
    </div>

    <!-- Reddit Tab -->
    <div id="reddit-tab" class="tab-content">
      <div id="reddit-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="reddit-content" class="hidden">
        <div id="reddit-list" class="content-list"></div>
      </div>
      <div id="reddit-empty" class="empty-state hidden">
        No Reddit posts found
      </div>
      <div id="reddit-unavailable" class="empty-state hidden">
        Reddit integration not configured
      </div>
    </div>
  </div>
</div>

<style>
  .intel-widget {
    width: 100%;
    max-width: 600px;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 0.375rem;
  }

  .tabs-nav {
    display: flex;
    border-bottom: 1px solid var(--border);
    background-color: transparent;
  }

  :global(.dark) .tabs-nav {
    border-bottom-color: var(--border-dark);
  }

  .tab-btn {
    flex: 1;
    padding: 0.875rem 0.5rem;
    min-height: 48px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 0.9rem;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: color 0.15s, border-color 0.15s;
  }

  :global(.dark) .tab-btn {
    color: var(--text-secondary-dark);
  }

  .tab-btn:hover {
    color: var(--text);
  }

  :global(.dark) .tab-btn:hover {
    color: var(--text-dark);
  }

  .tab-btn.active {
    color: var(--text);
    border-bottom-color: var(--text);
  }

  :global(.dark) .tab-btn.active {
    color: var(--text-dark);
    border-bottom-color: var(--text-dark);
  }

  .tab-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tabs-content {
    padding: 1.5rem;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  .loading-skeleton {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .skeleton-item {
    height: 80px;
    border-radius: 4px;
    background-color: var(--border);
    animation: pulse 2s ease-in-out infinite;
  }

  :global(.dark) .skeleton-item {
    background-color: var(--border-dark);
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .content-list {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .content-item {
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border);
  }

  :global(.dark) .content-item {
    border-bottom-color: var(--border-dark);
  }

  .content-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }

  .content-title {
    font-weight: 600;
    color: var(--text);
    margin: 0 0 0.5rem 0;
    line-height: 1.4;
    font-size: 0.95rem;
  }

  :global(.dark) .content-title {
    color: var(--text-dark);
  }

  .content-title a {
    color: inherit;
    text-decoration: underline;
    text-decoration-color: var(--text-tertiary);
    text-underline-offset: 2px;
  }

  :global(.dark) .content-title a {
    text-decoration-color: var(--text-tertiary-dark);
  }

  .content-meta {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-top: 0.5rem;
  }

  :global(.dark) .content-meta {
    color: var(--text-secondary-dark);
  }

  .content-excerpt {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.5;
    margin: 0.5rem 0 0;
  }

  :global(.dark) .content-excerpt {
    color: var(--text-secondary-dark);
  }

  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
  }

  :global(.dark) .empty-state {
    color: var(--text-secondary-dark);
  }

  .hidden {
    display: none !important;
  }

  /* Responsive - Mobile */
  @media (max-width: 480px) {
    .tabs-nav {
      gap: 0;
    }

    .tab-btn {
      padding: 0.75rem 0.25rem;
      font-size: 0.8rem;
    }

    .tabs-content {
      padding: 1rem;
    }

    .content-title {
      font-size: 0.9rem;
    }

    .content-excerpt {
      font-size: 0.8rem;
    }
  }

  /* Extra small screens */
  @media (max-width: 320px) {
    .tab-btn {
      font-size: 0.75rem;
      padding: 0.75rem 0.125rem;
    }

    .tabs-content {
      padding: 0.75rem;
    }
  }
</style>

<script>
  import { escapeHtml, parseEntityParams } from '../lib/utils/dom';
  import { formatDate } from '../lib/utils/date';
  import { swrFetch, waitForPageData, getPageData, setPageData, CACHE_PRESETS } from '../lib/utils/api-fetcher';

  // API Response types
  interface NewsArticle {
    title: string;
    url: string;
    source?: string;
    published_at?: string;
    description?: string;
    image_url?: string | null;
  }

  interface NewsResponse {
    query: string;
    sport: string;
    articles: NewsArticle[];
    meta?: {
      total_results: number;
      returned: number;
    };
  }

  interface IntelStatusResponse {
    services: {
      twitter: { configured: boolean };
      news: { configured: boolean };
      reddit: { configured: boolean };
    };
  }

  interface ProfileResponse {
    entity_id: number;
    entity_type: string;
    info: {
      full_name?: string;
      first_name?: string;
      last_name?: string;
      name?: string;
      team?: { name: string };
    };
  }

  class IntelWidget {
    private widget: HTMLElement | null = null;
    private apiUrl = '';
    private sport: string | null = null;
    private type: string | null = null;
    private id: string | null = null;

    // Entity info for fetching
    private entityName: string | null = null;
    private entityTeam: string | null = null;

    // Service availability
    private twitterEnabled = false;
    private redditEnabled = false;

    // Lazy loading flags
    private newsLoaded = false;
    private twitterLoaded = false;
    private redditLoaded = false;

    constructor() {
      const widget = document.getElementById('intel-widget');
      if (!widget) return;

      this.widget = widget;
      this.apiUrl = widget.dataset.apiUrl || 'http://localhost:8000/api/v1';

      const params = parseEntityParams();
      this.sport = params.sport;
      this.type = params.type;
      this.id = params.id;

      this.init();
    }

    private async init() {
      this.bindTabEvents();

      if (!this.sport || !this.type || !this.id) {
        this.showNewsEmpty();
        return;
      }

      // Check intel API availability
      await this.checkIntelStatus();

      // Get entity name from profile widget or fetch it
      await this.getEntityInfo();

      // Load news immediately (first tab)
      this.fetchNews();
    }

    private async checkIntelStatus() {
      try {
        const { data } = await swrFetch<IntelStatusResponse>(`${this.apiUrl}/intel/status`, CACHE_PRESETS.intel);
        this.twitterEnabled = data?.services?.twitter?.configured ?? false;
        this.redditEnabled = data?.services?.reddit?.configured ?? false;
      } catch {
        // Default to disabled
        this.twitterEnabled = false;
        this.redditEnabled = false;
      }

      this.updateTabAvailability();
    }

    private updateTabAvailability() {
      if (!this.widget) return;

      const twitterTab = this.widget.querySelector('[data-tab="twitter"]');
      const redditTab = this.widget.querySelector('[data-tab="reddit"]');

      if (twitterTab && !this.twitterEnabled) {
        twitterTab.classList.add('disabled');
      }
      if (redditTab && !this.redditEnabled) {
        redditTab.classList.add('disabled');
      }
    }

    private async getEntityInfo() {
      // Try to get from profile widget first
      let profileData = getPageData('widget') as ProfileResponse | undefined;

      if (!profileData) {
        try {
          profileData = await waitForPageData('widget', 1000) as ProfileResponse;
        } catch {
          // Fetch profile ourselves
          const url = `${this.apiUrl}/widget/profile/${this.type}/${this.id}?sport=${this.sport!.toUpperCase()}`;
          const { data } = await swrFetch<ProfileResponse>(url, CACHE_PRESETS.widget);
          profileData = data;
          setPageData('widget', data);
        }
      }

      if (profileData?.info) {
        const info = profileData.info;
        if (profileData.entity_type === 'team') {
          this.entityName = info.name || info.full_name || null;
        } else {
          this.entityName = info.full_name ||
            `${info.first_name || ''} ${info.last_name || ''}`.trim() ||
            null;
          this.entityTeam = info.team?.name || null;
        }
      }
    }

    private bindTabEvents() {
      if (!this.widget) return;

      this.widget.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const target = e.currentTarget as HTMLButtonElement;
          const tab = target.dataset.tab;

          // Don't switch to disabled tabs
          if (target.classList.contains('disabled')) return;

          // Update active tab button
          this.widget!.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          target.classList.add('active');

          // Update active tab content
          this.widget!.querySelectorAll('.tab-content').forEach(p => p.classList.remove('active'));
          const panel = document.getElementById(`${tab}-tab`);
          if (panel) panel.classList.add('active');

          // Lazy-load content
          if (tab === 'news' && !this.newsLoaded) {
            this.fetchNews();
          }
          if (tab === 'twitter' && !this.twitterLoaded) {
            this.fetchTwitter();
          }
          if (tab === 'reddit' && !this.redditLoaded) {
            this.fetchReddit();
          }
        });
      });
    }

    // News fetching
    private async fetchNews() {
      if (!this.entityName) {
        this.showNewsEmpty();
        return;
      }

      this.newsLoaded = true;

      try {
        const params = new URLSearchParams();
        if (this.sport) params.set('sport', this.sport.toUpperCase());
        if (this.entityTeam) params.set('team', this.entityTeam);
        params.set('limit', '10');

        const url = `${this.apiUrl}/news/${encodeURIComponent(this.entityName)}?${params.toString()}`;
        const { data } = await swrFetch<NewsResponse>(url, CACHE_PRESETS.news);

        const articles = data?.articles || [];
        if (articles.length === 0) {
          this.showNewsEmpty();
          return;
        }

        // Share news data
        setPageData('news', { articles });

        this.renderNews(articles);
      } catch {
        this.showNewsEmpty();
      }
    }

    private renderNews(articles: NewsArticle[]) {
      const listEl = document.getElementById('news-list');
      if (!listEl) return;

      const html = articles.map(article => {
        const title = escapeHtml(article.title || 'Untitled');
        const link = article.url || '#';
        const source = escapeHtml(article.source || '');
        const date = formatDate(article.published_at);

        return `<div class="content-item">
          <h3 class="content-title">
            <a href="${link}" target="_blank" rel="noopener">${title}</a>
          </h3>
          <div class="content-meta">${source}${source && date ? ' · ' : ''}${date}</div>
        </div>`;
      }).join('');

      listEl.innerHTML = html;
      this.showNewsContent();
    }

    private showNewsContent() {
      document.getElementById('news-loading')?.classList.add('hidden');
      document.getElementById('news-content')?.classList.remove('hidden');
      document.getElementById('news-empty')?.classList.add('hidden');
    }

    private showNewsEmpty() {
      document.getElementById('news-loading')?.classList.add('hidden');
      document.getElementById('news-content')?.classList.add('hidden');
      document.getElementById('news-empty')?.classList.remove('hidden');
    }

    // Twitter fetching
    private async fetchTwitter() {
      if (!this.entityName) {
        this.showTwitterEmpty();
        return;
      }

      if (!this.twitterEnabled) {
        this.showTwitterUnavailable();
        return;
      }

      this.twitterLoaded = true;

      try {
        const params = new URLSearchParams();
        params.set('query', this.entityName);
        if (this.sport) params.set('sport', this.sport.toUpperCase());
        params.set('limit', '10');

        const url = `${this.apiUrl}/intel/twitter?${params.toString()}`;
        const { data } = await swrFetch<{
          tweets?: Array<{
            id: string;
            text: string;
            author: string;
            author_username: string;
            created_at: string;
            metrics?: { like_count?: number; retweet_count?: number };
          }>;
        }>(url, CACHE_PRESETS.intel);

        const tweets = data?.tweets || [];
        if (tweets.length === 0) {
          this.showTwitterEmpty();
          return;
        }

        this.renderTwitter(tweets);
      } catch {
        this.showTwitterEmpty();
      }
    }

    private renderTwitter(tweets: Array<{ id: string; text: string; author: string; author_username: string; created_at: string; metrics?: { like_count?: number; retweet_count?: number } }>) {
      const listEl = document.getElementById('twitter-list');
      if (!listEl) return;

      const html = tweets.map(tweet => {
        const text = escapeHtml(tweet.text);
        const username = escapeHtml(tweet.author_username);
        const date = formatDate(tweet.created_at);
        const likes = tweet.metrics?.like_count || 0;
        const retweets = tweet.metrics?.retweet_count || 0;

        return `<div class="content-item">
          <p class="content-excerpt">${text}</p>
          <div class="content-meta">@${username} · ${date} · ${likes} likes · ${retweets} retweets</div>
        </div>`;
      }).join('');

      listEl.innerHTML = html;
      this.showTwitterContent();
    }

    private showTwitterContent() {
      document.getElementById('twitter-loading')?.classList.add('hidden');
      document.getElementById('twitter-content')?.classList.remove('hidden');
      document.getElementById('twitter-empty')?.classList.add('hidden');
      document.getElementById('twitter-unavailable')?.classList.add('hidden');
    }

    private showTwitterEmpty() {
      document.getElementById('twitter-loading')?.classList.add('hidden');
      document.getElementById('twitter-content')?.classList.add('hidden');
      document.getElementById('twitter-empty')?.classList.remove('hidden');
      document.getElementById('twitter-unavailable')?.classList.add('hidden');
    }

    private showTwitterUnavailable() {
      document.getElementById('twitter-loading')?.classList.add('hidden');
      document.getElementById('twitter-content')?.classList.add('hidden');
      document.getElementById('twitter-empty')?.classList.add('hidden');
      document.getElementById('twitter-unavailable')?.classList.remove('hidden');
    }

    // Reddit fetching
    private async fetchReddit() {
      if (!this.entityName) {
        this.showRedditEmpty();
        return;
      }

      if (!this.redditEnabled) {
        this.showRedditUnavailable();
        return;
      }

      this.redditLoaded = true;

      try {
        const params = new URLSearchParams();
        params.set('query', this.entityName);
        if (this.sport) params.set('sport', this.sport.toUpperCase());
        params.set('sort', 'hot');
        params.set('limit', '10');

        const url = `${this.apiUrl}/intel/reddit?${params.toString()}`;
        const { data } = await swrFetch<{
          posts?: Array<{
            id: string;
            title: string;
            selftext?: string;
            author: string;
            subreddit: string;
            created_utc: number;
            score: number;
            num_comments: number;
            url: string;
          }>;
        }>(url, CACHE_PRESETS.intel);

        const posts = data?.posts || [];
        if (posts.length === 0) {
          this.showRedditEmpty();
          return;
        }

        this.renderReddit(posts);
      } catch {
        this.showRedditEmpty();
      }
    }

    private renderReddit(posts: Array<{ id: string; title: string; selftext?: string; author: string; subreddit: string; created_utc: number; score: number; num_comments: number; url: string }>) {
      const listEl = document.getElementById('reddit-list');
      if (!listEl) return;

      const html = posts.map(post => {
        const title = escapeHtml(post.title);
        const subreddit = escapeHtml(post.subreddit);
        const author = escapeHtml(post.author);
        const date = formatDate(new Date(post.created_utc * 1000).toISOString());

        return `<div class="content-item">
          <h3 class="content-title">
            <a href="${post.url}" target="_blank" rel="noopener">${title}</a>
          </h3>
          <div class="content-meta">r/${subreddit} · u/${author} · ${date} · ${post.score} points · ${post.num_comments} comments</div>
        </div>`;
      }).join('');

      listEl.innerHTML = html;
      this.showRedditContent();
    }

    private showRedditContent() {
      document.getElementById('reddit-loading')?.classList.add('hidden');
      document.getElementById('reddit-content')?.classList.remove('hidden');
      document.getElementById('reddit-empty')?.classList.add('hidden');
      document.getElementById('reddit-unavailable')?.classList.add('hidden');
    }

    private showRedditEmpty() {
      document.getElementById('reddit-loading')?.classList.add('hidden');
      document.getElementById('reddit-content')?.classList.add('hidden');
      document.getElementById('reddit-empty')?.classList.remove('hidden');
      document.getElementById('reddit-unavailable')?.classList.add('hidden');
    }

    private showRedditUnavailable() {
      document.getElementById('reddit-loading')?.classList.add('hidden');
      document.getElementById('reddit-content')?.classList.add('hidden');
      document.getElementById('reddit-empty')?.classList.add('hidden');
      document.getElementById('reddit-unavailable')?.classList.remove('hidden');
    }
  }

  new IntelWidget();
</script>
