---
/**
 * Content Card with 4 Tabs
 * 
 * Displays content for an entity across 4 tabs:
 * - Articles
 * - Co-mentions
 * - Tweets
 * - Reddit
 * 
 * Used on the mentions page below the entity widget
 * Tab content is populated from the backend API
 */

// Get API URL at build time and pass to client
const apiUrl = import.meta.env.PUBLIC_API_URL || 'http://localhost:8000/api/v1';
---

<div id="content-card" class="content-card card" data-api-url={apiUrl}>
  <!-- Tab Navigation -->
  <div class="tabs-nav">
    <button class="tab-btn active" data-tab="articles">Articles</button>
    <button class="tab-btn" data-tab="co-mentions">Co-mentions</button>
    <button class="tab-btn" data-tab="tweets">Tweets</button>
    <button class="tab-btn" data-tab="reddit">Reddit</button>
  </div>

  <!-- Tab Content -->
  <div class="tabs-content">
    <!-- Articles Tab -->
    <div id="articles-tab" class="tab-content active">
      <div id="articles-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="articles-content" class="hidden">
        <div id="articles-list" class="content-list"></div>
      </div>
      <div id="articles-empty" class="empty-state hidden">
        No articles found
      </div>
    </div>

    <!-- Co-mentions Tab -->
    <div id="co-mentions-tab" class="tab-content">
      <div id="co-mentions-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="co-mentions-content" class="hidden">
        <div id="co-mentions-list" class="content-list"></div>
      </div>
      <div id="co-mentions-empty" class="empty-state hidden">
        No co-mentions found
      </div>
    </div>

    <!-- Tweets Tab -->
    <div id="tweets-tab" class="tab-content">
      <div id="tweets-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="tweets-content" class="hidden">
        <div id="tweets-list" class="content-list"></div>
      </div>
      <div id="tweets-empty" class="empty-state hidden">
        No tweets found
      </div>
    </div>

    <!-- Reddit Tab -->
    <div id="reddit-tab" class="tab-content">
      <div id="reddit-loading" class="loading-skeleton">
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
        <div class="skeleton-item"></div>
      </div>
      <div id="reddit-content" class="hidden">
        <div id="reddit-list" class="content-list"></div>
      </div>
      <div id="reddit-empty" class="empty-state hidden">
        No Reddit posts found
      </div>
    </div>
  </div>
</div>

<style scoped>
  .content-card {
    width: 100%;
    max-width: 600px;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 0.375rem;
  }

  .tabs-nav {
    display: flex;
    border-bottom: 1px solid var(--border);
    background-color: transparent;
  }

  :global(.dark) .tabs-nav {
    border-bottom-color: var(--border-dark);
  }

  .tab-btn {
    flex: 1;
    padding: 0.875rem 0.5rem;
    min-height: 48px;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 0.9rem;
    cursor: pointer;
    border-bottom: 2px solid transparent;
  }

  :global(.dark) .tab-btn {
    color: var(--text-secondary-dark);
  }

  .tab-btn.active {
    color: var(--text);
    border-bottom-color: var(--text);
  }

  :global(.dark) .tab-btn.active {
    color: var(--text-dark);
    border-bottom-color: var(--text-dark);
  }

  .tabs-content {
    padding: 1.5rem;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  .loading-skeleton {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .skeleton-item {
    height: 80px;
    border-radius: 4px;
    background-color: var(--border);
    animation: pulse 2s ease-in-out infinite;
  }

  :global(.dark) .skeleton-item {
    background-color: var(--border-dark);
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .content-list {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .content-item {
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border);
  }

  :global(.dark) .content-item {
    border-bottom-color: var(--border-dark);
  }

  .content-item:last-child {
    border-bottom: none;
  }

  .content-title {
    font-weight: 600;
    color: var(--text);
    margin: 0 0 0.5rem 0;
    line-height: 1.4;
    font-size: 0.95rem;
  }

  :global(.dark) .content-title {
    color: var(--text-dark);
  }

  .content-title a {
    color: inherit;
    text-decoration: underline;
    text-decoration-color: var(--text-tertiary);
    text-underline-offset: 2px;
  }

  :global(.dark) .content-title a {
    text-decoration-color: var(--text-tertiary-dark);
  }

  .content-meta {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-top: 0.5rem;
  }

  :global(.dark) .content-meta {
    color: var(--text-secondary-dark);
  }

  .content-excerpt {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.5;
    margin-top: 0.5rem;
  }

  :global(.dark) .content-excerpt {
    color: var(--text-secondary-dark);
  }

  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
  }

  :global(.dark) .empty-state {
    color: var(--text-secondary-dark);
  }

  .hidden {
    display: none;
  }

  /* Co-mentions specific styles */
  .co-mention-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .co-mention-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
  }

  .co-mention-name {
    font-weight: 600;
    color: var(--text);
    text-decoration: underline;
    text-decoration-color: var(--text-tertiary);
    text-underline-offset: 2px;
  }

  :global(.dark) .co-mention-name {
    color: var(--text-dark);
    text-decoration-color: var(--text-tertiary-dark);
  }

  .co-mention-count {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    background-color: var(--border);
    padding: 0.2rem 0.5rem;
    border-radius: 2px;
    white-space: nowrap;
  }

  :global(.dark) .co-mention-count {
    color: var(--text-secondary-dark);
    background-color: var(--border-dark);
  }

  /* Responsive - Mobile */
  @media (max-width: 480px) {
    .tabs-nav {
      gap: 0;
    }

    .tab-btn {
      padding: 0.75rem 0.25rem;
      font-size: 0.8rem;
    }

    .tabs-content {
      padding: 1rem;
    }

    .content-title {
      font-size: 0.9rem;
    }

    .content-excerpt {
      font-size: 0.8rem;
    }
  }

  /* Extra small screens */
  @media (max-width: 320px) {
    .tab-btn {
      font-size: 0.75rem;
      padding: 0.75rem 0.125rem;
    }

    .tabs-content {
      padding: 0.75rem;
    }
  }
</style>

<script>
  import { escapeHtml, parseEntityParams } from '../lib/utils/dom';
  import { formatDate } from '../lib/utils/date';
  import {
    findCoMentions,
    loadEntitiesForSport,
    type Article,
    type CoMention,
  } from '../lib/utils/co-mentions';
  import { swrFetch, waitForPageData, getPageData, setPageData, fetchIntelStatus, CACHE_PRESETS } from '../lib/utils/api-fetcher';

  // Extended article interface for rendering
  interface ArticleDisplay {
    title?: string;
    link?: string;
    source?: string;
    pub_date?: string;
  }

  class ContentCard {
    private card: HTMLElement | null = null;
    private apiUrl = '';
    private sport: string | null = null;
    private type: string | null = null;
    private id: string | null = null;

    // Store entity info for news fetching
    private entityName: string | null = null;
    private entityTeam: string | null = null;

    // Store articles for co-mentions
    private articles: Article[] = [];

    // Articles tab elements
    private loadingEl: HTMLElement | null = null;
    private contentEl: HTMLElement | null = null;
    private listEl: HTMLElement | null = null;
    private emptyEl: HTMLElement | null = null;

    // Co-mentions tab elements
    private coMentionsLoadingEl: HTMLElement | null = null;
    private coMentionsContentEl: HTMLElement | null = null;
    private coMentionsListEl: HTMLElement | null = null;
    private coMentionsEmptyEl: HTMLElement | null = null;
    private coMentionsLoaded = false;

    // Lazy loading flags for tweets and reddit
    private tweetsLoaded = false;
    private redditLoaded = false;

    // Intel API availability
    private twitterEnabled = false;
    private redditEnabled = false;

    constructor() {
      const card = document.getElementById('content-card');
      if (!card) return;

      this.card = card;
      this.apiUrl = card.dataset.apiUrl || 'http://localhost:8000/api/v1';

      const params = parseEntityParams();
      this.sport = params.sport;
      this.type = params.type;
      this.id = params.id;

      this.loadingEl = document.getElementById('articles-loading');
      this.contentEl = document.getElementById('articles-content');
      this.listEl = document.getElementById('articles-list');
      this.emptyEl = document.getElementById('articles-empty');

      // Initialize co-mentions elements
      this.coMentionsLoadingEl = document.getElementById('co-mentions-loading');
      this.coMentionsContentEl = document.getElementById('co-mentions-content');
      this.coMentionsListEl = document.getElementById('co-mentions-list');
      this.coMentionsEmptyEl = document.getElementById('co-mentions-empty');

      this.init();
    }

    private async init() {
      this.bindTabEvents();

      if (!this.sport || !this.type || !this.id) {
        this.showEmpty();
        return;
      }

      // Check Intel API availability and update tabs accordingly
      await this.checkIntelStatus();

      this.fetchData();
    }

    private async checkIntelStatus() {
      try {
        const status = await fetchIntelStatus(this.apiUrl);
        this.twitterEnabled = status.twitter;
        this.redditEnabled = status.reddit;

        // Update tab visibility based on API availability
        this.updateTabVisibility();
      } catch {
        // On error, hide both intel tabs
        this.updateTabVisibility();
      }
    }

    private updateTabVisibility() {
      if (!this.card) return;

      const tweetsTab = this.card.querySelector('[data-tab="tweets"]') as HTMLElement;
      const redditTab = this.card.querySelector('[data-tab="reddit"]') as HTMLElement;

      // Hide tabs if their APIs are not available
      if (tweetsTab && !this.twitterEnabled) {
        tweetsTab.style.display = 'none';
      }
      if (redditTab && !this.redditEnabled) {
        redditTab.style.display = 'none';
      }
    }

    private bindTabEvents() {
      if (!this.card) return;
      this.card.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const target = e.currentTarget as HTMLButtonElement;
          const tab = target.dataset.tab;

          this.card!.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          target.classList.add('active');

          this.card!.querySelectorAll('.tab-content').forEach(p => p.classList.remove('active'));
          const panel = document.getElementById(`${tab}-tab`);
          if (panel) panel.classList.add('active');

          // Lazy-load content when tabs are clicked
          if (tab === 'co-mentions' && !this.coMentionsLoaded) {
            this.fetchCoMentions();
          }
          if (tab === 'tweets' && !this.tweetsLoaded) {
            this.fetchTweets();
          }
          if (tab === 'reddit' && !this.redditLoaded) {
            this.fetchReddit();
          }
        });
      });
    }

    private async fetchData() {
      try {
        // Try to get widget data from shared store first (EntityWidget may have fetched it)
        // This avoids duplicate fetch when both components are on the same page
        let widgetData = getPageData('widget') as Record<string, unknown> | undefined;

        if (!widgetData) {
          // Wait briefly for EntityWidget to populate data, then fetch if not available
          try {
            widgetData = await waitForPageData('widget', 500) as Record<string, unknown>;
          } catch {
            // EntityWidget hasn't loaded data yet - fetch ourselves using SWR
            // SWR will deduplicate if EntityWidget also requests the same URL
            const url = `${this.apiUrl}/widget/profile/${this.type}/${this.id}?sport=${this.sport!.toUpperCase()}`;
            const { data } = await swrFetch<Record<string, unknown>>(url, CACHE_PRESETS.widget);
            widgetData = data;
            setPageData('widget', data);
          }
        }

        // New API returns flat data - extract entity name
        let entityName: string | undefined;
        if (this.type === 'team') {
          entityName = widgetData.name as string;
        } else {
          entityName = `${widgetData.firstname || ''} ${widgetData.lastname || ''}`.trim() || (widgetData.name as string);
        }

        if (!entityName) {
          this.showEmpty();
          return;
        }

        // Store entity info for later use
        this.entityName = entityName;

        // Extract team name for players (improves news search relevance)
        if (this.type === 'player') {
          this.entityTeam = (widgetData.team_name || null) as string | null;
        }

        // Build news URL with sport and team context for better search results
        const newsParams = new URLSearchParams();
        if (this.sport) newsParams.set('sport', this.sport.toUpperCase());
        if (this.entityTeam) newsParams.set('team', this.entityTeam);
        newsParams.set('limit', '10'); // New API uses limit

        const newsUrl = `${this.apiUrl}/news/${encodeURIComponent(entityName)}?${newsParams.toString()}`;

        // Use SWR fetch for news with preset cache times
        const { data: newsData } = await swrFetch<{ articles?: Array<{ title?: string; url?: string; published_at?: string; source?: string; description?: string }> }>(newsUrl, CACHE_PRESETS.news);

        // Transform new API response (url → link, published_at → pub_date)
        const rawArticles = newsData.articles || [];
        const articles: ArticleDisplay[] = rawArticles.map(a => ({
          title: a.title,
          link: a.url,
          pub_date: a.published_at,
          source: a.source,
        }));

        // Store articles for co-mentions (with required Article shape)
        this.articles = articles.map(a => ({
          title: a.title || '',
          link: a.link || '',
          pub_date: a.pub_date,
          source: a.source,
        }));

        // Share news data with other components
        setPageData('news', { articles: this.articles });

        if (articles.length === 0) {
          this.showEmpty();
          return;
        }

        this.renderArticles(articles);
      } catch {
        this.showEmpty();
      }
    }

    private renderArticles(articles: ArticleDisplay[]) {
      const html = articles.map(article => this.renderArticle(article)).join('');
      if (this.listEl) this.listEl.innerHTML = html;
      this.showContent();
    }

    private renderArticle(article: ArticleDisplay): string {
      const title = escapeHtml(article.title || 'Untitled');
      const link = article.link || '#';
      const source = escapeHtml(article.source || '');
      const date = formatDate(article.pub_date);

      return `<div class="content-item">
        <h3 class="content-title">
          <a href="${link}" target="_blank" rel="noopener">${title}</a>
        </h3>
        <div class="content-meta">${source}${source && date ? ' · ' : ''}${date}</div>
      </div>`;
    }

    private showContent() {
      this.loadingEl?.classList.add('hidden');
      this.contentEl?.classList.remove('hidden');
      this.emptyEl?.classList.add('hidden');
    }

    private showEmpty() {
      this.loadingEl?.classList.add('hidden');
      this.contentEl?.classList.add('hidden');
      this.emptyEl?.classList.remove('hidden');
    }

    // Co-mentions methods - now using frontend logic
    private async fetchCoMentions() {
      if (!this.sport || !this.type || !this.id) {
        this.showCoMentionsEmpty();
        return;
      }

      // If we don't have articles yet, we can't find co-mentions
      if (this.articles.length === 0) {
        this.showCoMentionsEmpty();
        return;
      }

      try {
        // Load all entities for this sport from static JSON
        const entities = await loadEntitiesForSport(this.sport);

        // Find co-mentions using frontend logic (2-part name matching)
        const coMentions = findCoMentions(
          this.articles,
          entities,
          this.id,
          this.type as 'player' | 'team'
        );

        this.coMentionsLoaded = true;

        if (coMentions.length === 0) {
          this.showCoMentionsEmpty();
          return;
        }

        this.renderCoMentions(coMentions);
      } catch (err) {
        if (import.meta.env.DEV) {
          console.error('Co-mentions error:', err);
        }
        this.showCoMentionsEmpty();
      }
    }

    private renderCoMentions(coMentions: CoMention[]) {
      const html = coMentions.map(cm => this.renderCoMention(cm)).join('');
      if (this.coMentionsListEl) this.coMentionsListEl.innerHTML = html;
      this.showCoMentionsContent();
    }

    private renderCoMention(cm: CoMention): string {
      const name = escapeHtml(cm.entity.name);
      const type = cm.entity.type === 'player' ? 'Player' : 'Team';
      const count = cm.mentionCount;
      const countLabel = count === 1 ? 'mention' : 'mentions';

      // Build link to the co-mentions comparison page
      const link = `/co-mentions?sport=${this.sport}&type=${this.type}&id=${this.id}&coType=${cm.entity.type}&coId=${cm.entity.id}`;

      return `<div class="content-item co-mention-item">
        <div class="co-mention-header">
          <a href="${link}" class="co-mention-name">${name}</a>
          <span class="co-mention-count">${count} ${countLabel}</span>
        </div>
        <div class="content-meta">${type}</div>
      </div>`;
    }

    private showCoMentionsContent() {
      this.coMentionsLoadingEl?.classList.add('hidden');
      this.coMentionsContentEl?.classList.remove('hidden');
      this.coMentionsEmptyEl?.classList.add('hidden');
    }

    private showCoMentionsEmpty() {
      this.coMentionsLoadingEl?.classList.add('hidden');
      this.coMentionsContentEl?.classList.add('hidden');
      this.coMentionsEmptyEl?.classList.remove('hidden');
    }

    // Twitter/Tweets lazy loading
    private async fetchTweets() {
      if (!this.entityName || !this.twitterEnabled) {
        this.showTweetsEmpty();
        return;
      }

      this.tweetsLoaded = true;

      try {
        // Use intel/twitter endpoint
        const params = new URLSearchParams();
        params.set('query', this.entityName);
        if (this.sport) params.set('sport', this.sport.toUpperCase());
        params.set('limit', '10');

        const url = `${this.apiUrl}/intel/twitter?${params.toString()}`;
        const { data } = await swrFetch<{
          tweets?: Array<{
            id: string;
            text: string;
            author: string;
            author_username: string;
            created_at: string;
            metrics?: { like_count?: number; retweet_count?: number };
          }>;
        }>(url, CACHE_PRESETS.intel);

        const tweets = data.tweets || [];
        if (tweets.length === 0) {
          this.showTweetsEmpty();
          return;
        }

        this.renderTweets(tweets);
      } catch {
        this.showTweetsEmpty();
      }
    }

    private renderTweets(tweets: Array<{ id: string; text: string; author: string; author_username: string; created_at: string; metrics?: { like_count?: number; retweet_count?: number } }>) {
      const listEl = document.getElementById('tweets-list');
      if (!listEl) return;

      const html = tweets.map(tweet => {
        const text = escapeHtml(tweet.text);
        const author = escapeHtml(tweet.author);
        const username = escapeHtml(tweet.author_username);
        const date = formatDate(tweet.created_at);
        const likes = tweet.metrics?.like_count || 0;
        const retweets = tweet.metrics?.retweet_count || 0;

        return `<div class="content-item">
          <p class="content-excerpt">${text}</p>
          <div class="content-meta">@${username} · ${date} · ${likes} likes · ${retweets} retweets</div>
        </div>`;
      }).join('');

      listEl.innerHTML = html;
      this.showTweetsContent();
    }

    private showTweetsContent() {
      document.getElementById('tweets-loading')?.classList.add('hidden');
      document.getElementById('tweets-content')?.classList.remove('hidden');
      document.getElementById('tweets-empty')?.classList.add('hidden');
    }

    private showTweetsEmpty() {
      document.getElementById('tweets-loading')?.classList.add('hidden');
      document.getElementById('tweets-content')?.classList.add('hidden');
      document.getElementById('tweets-empty')?.classList.remove('hidden');
    }

    // Reddit lazy loading
    private async fetchReddit() {
      if (!this.entityName || !this.redditEnabled) {
        this.showRedditEmpty();
        return;
      }

      this.redditLoaded = true;

      try {
        // Use intel/reddit endpoint
        const params = new URLSearchParams();
        params.set('query', this.entityName);
        if (this.sport) params.set('sport', this.sport.toUpperCase());
        params.set('sort', 'hot');
        params.set('limit', '10');

        const url = `${this.apiUrl}/intel/reddit?${params.toString()}`;
        const { data } = await swrFetch<{
          posts?: Array<{
            id: string;
            title: string;
            selftext?: string;
            author: string;
            subreddit: string;
            created_utc: number;
            score: number;
            num_comments: number;
            url: string;
          }>;
        }>(url, CACHE_PRESETS.intel);

        const posts = data.posts || [];
        if (posts.length === 0) {
          this.showRedditEmpty();
          return;
        }

        this.renderRedditPosts(posts);
      } catch {
        this.showRedditEmpty();
      }
    }

    private renderRedditPosts(posts: Array<{ id: string; title: string; selftext?: string; author: string; subreddit: string; created_utc: number; score: number; num_comments: number; url: string }>) {
      const listEl = document.getElementById('reddit-list');
      if (!listEl) return;

      const html = posts.map(post => {
        const title = escapeHtml(post.title);
        const subreddit = escapeHtml(post.subreddit);
        const author = escapeHtml(post.author);
        const date = formatDate(new Date(post.created_utc * 1000).toISOString());

        return `<div class="content-item">
          <h3 class="content-title">
            <a href="${post.url}" target="_blank" rel="noopener">${title}</a>
          </h3>
          <div class="content-meta">r/${subreddit} · u/${author} · ${date} · ${post.score} points · ${post.num_comments} comments</div>
        </div>`;
      }).join('');

      listEl.innerHTML = html;
      this.showRedditContent();
    }

    private showRedditContent() {
      document.getElementById('reddit-loading')?.classList.add('hidden');
      document.getElementById('reddit-content')?.classList.remove('hidden');
      document.getElementById('reddit-empty')?.classList.add('hidden');
    }

    private showRedditEmpty() {
      document.getElementById('reddit-loading')?.classList.add('hidden');
      document.getElementById('reddit-content')?.classList.add('hidden');
      document.getElementById('reddit-empty')?.classList.remove('hidden');
    }
  }

  new ContentCard();
</script>
